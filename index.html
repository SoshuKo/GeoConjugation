<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ジョージア語動詞活用ジェネレーター</title>
<style>
 body { font-family: sans-serif; }
 table { border-collapse: collapse; margin-bottom: 1em; }
 th, td { border: 1px solid #000; padding: 4px 8px; }
</style>
</head>
<body>
<h1>ジョージア語動詞活用ジェネレーター</h1>
<label for="dictForm">辞書形: </label>
<input id="dictForm" type="text">
<button id="convButton">活用する</button>
<div id="output"></div>
<script>
// 定義: 前母音・現在/未来マーカー・人称接尾辞
const PRE_VOWELS = ['ა', 'ე', 'ი', 'უ'];
const FUTURE_MARKERS = ['ამ', 'ავ', 'ებ', 'ობ', 'ოპ', 'ი', 'მ', 'ვ'];
const PERSON_SUFFIXES = ['ს', 'ა'];

function parseDictionaryForm(str) {
  const trimmed = str.trim();
  let preverb = '';
  let rest = trimmed;
  const eqIdx = trimmed.indexOf('=');
  if (eqIdx !== -1) {
    preverb = trimmed.slice(0, eqIdx);
    rest = trimmed.slice(eqIdx + 1);
  }
  const parts = rest.split('-').filter(p => p.length > 0);

  if (parts.length < 2) return null; // at least stem and suffix

  const suffix = parts.pop();
  if (!PERSON_SUFFIXES.includes(suffix)) return null;

  let preVowel = '';
  if (parts.length && parts[0].length === 1 && PRE_VOWELS.includes(parts[0])) {
    preVowel = parts.shift();
  }

  let stem = '', marker = '';
  if (parts.length === 2) {
    [stem, marker] = parts;
    if (!FUTURE_MARKERS.includes(marker)) return null;
  } else if (parts.length === 1) {
    [stem] = parts; // markerless
  } else {
    return null;
  }

  return { preverb, preVowel, stem, marker, suffix };
}

function buildForm(preVowel, stem, marker, suffix, infix, cond) {
  const tokens = [];
  if (infix) tokens.push(infix);
  if (preVowel) tokens.push(preVowel);
  tokens.push(stem);
  if (marker) tokens.push(marker);
  if (cond) tokens.push(cond);
  if (suffix) tokens.push(suffix);
  return tokens.join('-');
}

function buildFormFuture(preverb, preVowel, stem, marker, suffix, infix, cond) {
  const tokens = [];
  if (preverb) tokens.push(preverb);
  if (infix) tokens.push(infix);
  if (preVowel) tokens.push(preVowel);
  tokens.push(stem);
  if (marker) tokens.push(marker);
  if (cond) tokens.push(cond);
  if (suffix) tokens.push(suffix);
  return tokens.join('-');
}

function conjugatePresent(c) {
  const p = c.preVowel, s = c.stem, m = c.marker, base = c.suffix;
  return {
    '1sg': buildForm(p, s, m, '', 'ვ', ''),
    '2sg': buildForm(p, s, m, '', '', ''),
    '3sg': buildForm(p, s, m, base, '', ''),
    '1pl': buildForm(p, s, m, 'თ', 'ვ', ''),
    '2pl': buildForm(p, s, m, 'თ', '', ''),
    '3pl': buildForm(p, s, m, 'ენ', '', '')
  };
}

function conjugateImperfect(c) {
  const p = c.preVowel, s = c.stem, m = c.marker;
  const d = 'დ';
  return {
    '1sg': buildForm(p, s, m, 'ი', 'ვ', d),
    '2sg': buildForm(p, s, m, 'ი', '', d),
    '3sg': buildForm(p, s, m, 'ა', '', d),
    '1pl': buildForm(p, s, m, 'ით', 'ვ', d),
    '2pl': buildForm(p, s, m, 'ით', '', d),
    '3pl': buildForm(p, s, m, 'ნენ', '', d)
  };
}

function conjugateSubjunctive(c) {
  const p = c.preVowel, s = c.stem, m = c.marker;
  const d = 'დ';
  return {
    '1sg': buildForm(p, s, m, 'ე', 'ვ', d),
    '2sg': buildForm(p, s, m, 'ე', '', d),
    '3sg': buildForm(p, s, m, 'ეს', '', d),
    '1pl': buildForm(p, s, m, 'ეთ', 'ვ', d),
    '2pl': buildForm(p, s, m, 'ეთ', '', d),
    '3pl': buildForm(p, s, m, 'ნენ', '', d)
  };
}

function conjugateFuture(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb, base = c.suffix;
  return {
    '1sg': buildFormFuture(pre, pv, s, m, '', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, m, '', '', ''),
    '3sg': buildFormFuture(pre, pv, s, m, base, '', ''),
    '1pl': buildFormFuture(pre, pv, s, m, 'თ', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, m, 'თ', '', ''),
    '3pl': buildFormFuture(pre, pv, s, m, 'ენ', '', '')
  };
}

function conjugateConditional(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb;
  const d = 'დ';
  return {
    '1sg': buildFormFuture(pre, pv, s, m, 'ი', 'ვ', d),
    '2sg': buildFormFuture(pre, pv, s, m, 'ი', '', d),
    '3sg': buildFormFuture(pre, pv, s, m, 'ა', '', d),
    '1pl': buildFormFuture(pre, pv, s, m, 'ით', 'ვ', d),
    '2pl': buildFormFuture(pre, pv, s, m, 'ით', '', d),
    '3pl': buildFormFuture(pre, pv, s, m, 'ნენ', '', d)
  };
}

function conjugateFutureSubjunctive(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb;
  const d = 'დ';
  return {
    '1sg': buildFormFuture(pre, pv, s, m, 'ე', 'ვ', d),
    '2sg': buildFormFuture(pre, pv, s, m, 'ე', '', d),
    '3sg': buildFormFuture(pre, pv, s, m, 'ეს', '', d),
    '1pl': buildFormFuture(pre, pv, s, m, 'ეთ', 'ვ', d),
    '2pl': buildFormFuture(pre, pv, s, m, 'ეთ', '', d),
    '3pl': buildFormFuture(pre, pv, s, m, 'ნენ', '', d)
  };
}

function conjugateAorist(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, pre = c.preverb;
  return {
    '1sg': buildFormFuture(pre, pv, s, '', 'ე', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, '', 'ე', '', ''),
    '3sg': buildFormFuture(pre, pv, s, '', 'ა', '', ''),
    '1pl': buildFormFuture(pre, pv, s, '', 'ეთ', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, '', 'ეთ', '', ''),
    '3pl': buildFormFuture(pre, pv, s, '', 'ეს', '', '')
  };
}

function conjugateOptative(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, pre = c.preverb;
  return {
    '1sg': buildFormFuture(pre, pv, s, '', 'ო', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, '', 'ო', '', ''),
    '3sg': buildFormFuture(pre, pv, s, '', 'ოს', '', ''),
    '1pl': buildFormFuture(pre, pv, s, '', 'ოთ', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, '', 'ოთ', '', ''),
    '3pl': buildFormFuture(pre, pv, s, '', 'ონ', '', '')
  };
}

function conjugatePresentPerfect(c) {
  const pre = c.preverb, s = c.stem, m = c.marker;
  return {
    '1sg': buildFormFuture(pre, 'ი', s, m, 'ია', 'მ', ''),
    '2sg': buildFormFuture(pre, 'ი', s, m, 'ია', 'გ', ''),
    '3sg': buildFormFuture(pre, 'უ', s, m, 'ია', '', ''),
    '1pl': buildFormFuture(pre, 'ი', s, m, 'ია', 'გვ', ''),
    '2pl': buildFormFuture(pre, 'ი', s, m, 'იათ', 'გ', ''),
    '3pl': buildFormFuture(pre, 'უ', s, m, 'იათ', '', '')
  };
}

function conjugatePastPerfect(c) {
  const pre = c.preverb, s = c.stem, m = c.marker;
  return {
    '1sg': buildFormFuture(pre, 'ე', s, m, 'ინა', 'მ', ''),
    '2sg': buildFormFuture(pre, 'ე', s, m, 'ინა', 'გ', ''),
    '3sg': buildFormFuture(pre, 'ე', s, m, 'ინა', '', ''),
    '1pl': buildFormFuture(pre, 'ე', s, m, 'ინა', 'გვ', ''),
    '2pl': buildFormFuture(pre, 'ე', s, m, 'ინათ', 'გ', ''),
    '3pl': buildFormFuture(pre, 'ე', s, m, 'ინათ', '', '')
  };
}

function conjugatePerfectSubjunctive(c) {
  const pre = c.preverb, s = c.stem, m = c.marker;
  return {
    '1sg': buildFormFuture(pre, 'ე', s, m, 'ინოს', 'მ', ''),
    '2sg': buildFormFuture(pre, 'ე', s, m, 'ინოს', 'გ', ''),
    '3sg': buildFormFuture(pre, 'ე', s, m, 'ინოს', '', ''),
    '1pl': buildFormFuture(pre, 'ე', s, m, 'ინოს', 'გვ', ''),
    '2pl': buildFormFuture(pre, 'ე', s, m, 'ინოთ', 'გ', ''),
    '3pl': buildFormFuture(pre, 'ე', s, m, 'ინოთ', '', '')
  };
}

function renderTable(title, forms) {
  return '<h3>' + title + '</h3>' +
    '<table>' +
    '<tr><th>人称</th><th>活用形</th></tr>' +
    '<tr><th>1単</th><td>' + forms['1sg'] + '</td></tr>' +
    '<tr><th>2単</th><td>' + forms['2sg'] + '</td></tr>' +
    '<tr><th>3単</th><td>' + forms['3sg'] + '</td></tr>' +
    '<tr><th>1複</th><td>' + forms['1pl'] + '</td></tr>' +
    '<tr><th>2複</th><td>' + forms['2pl'] + '</td></tr>' +
    '<tr><th>3複</th><td>' + forms['3pl'] + '</td></tr>' +
    '</table>';
}

function generate() {
  const input = document.getElementById('dictForm').value;
  const comp = parseDictionaryForm(input);
  if (!comp) {
    document.getElementById('output').textContent = '解析できませんでした。';
    return;
  }
  const pres = conjugatePresent(comp);
  const impf = conjugateImperfect(comp);
  const subj = conjugateSubjunctive(comp);
  const pperf = conjugatePresentPerfect(comp);
  const iperf = conjugatePastPerfect(comp);
  const sperf = conjugatePerfectSubjunctive(comp);
  let html = renderTable('現在', pres) +
    renderTable('未完了過去', impf) +
    renderTable('接続法現在', subj) +
    renderTable('現在完了', pperf) +
    renderTable('過去完了', iperf) +
    renderTable('接続法完了', sperf);

  if (comp.preverb) {
    const fut = conjugateFuture(comp);
    const cond = conjugateConditional(comp);
    const fsub = conjugateFutureSubjunctive(comp);
    const aor = conjugateAorist(comp);
    const opt = conjugateOptative(comp);
    html += renderTable('未来', fut) +
      renderTable('条件法', cond) +
      renderTable('接続法未来', fsub) +
      renderTable('アオリスト', aor) +
      renderTable('希求法', opt);
  } else {
    html += '<p>この動詞は未来亜系統には活用できません</p>';
    html += '<p>この動詞はアオリスト亜系統には活用できません</p>';
  }
  document.getElementById('output').innerHTML = html;
}

document.getElementById('convButton').addEventListener('click', generate);
</script>
</body>
</html>
