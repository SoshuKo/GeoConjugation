<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ジョージア語動詞活用ジェネレーター</title>
<style>
 body {
   font-family: "Segoe UI", "Hiragino Kaku Gothic Pro", sans-serif;
   background: #f5f5f5;
   padding: 1em;
 }
 table {
   border-collapse: collapse;
   margin-bottom: 1em;
   width: 100%;
 }
 th, td {
   border: 1px solid #444;
   padding: 6px 8px;
 }
 th {
   background: #ddd;
 }
 tr:hover td {
   background: #ffffcc;
   cursor: pointer;
 }
 td.copied {
   animation: flash 0.6s;
 }
@keyframes flash {
  from { background: #ffffcc; }
  to { background: #fff; }
}
option.highlight { background: #ff0; }
.hidden { display: none; }
details {
  margin-bottom: 0.5em;
}
summary {
  font-weight: bold;
  cursor: pointer;
  padding: 4px;
  background: #ccc;
  border: 1px solid #444;
}
table[data-tam="present"] { background:#eef; }
table[data-tam="imperfect"] { background:#efe; }
table[data-tam="subj"] { background:#ffe; }
table[data-tam="future"] { background:#eef5ff; }
table[data-tam="conditional"] { background:#f5fff0; }
table[data-tam="fsub"] { background:#fff5f0; }
table[data-tam="aorist"] { background:#f0f5ff; }
table[data-tam="optative"] { background:#f0fff5; }
table[data-tam="presperf"] { background:#fff0f5; }
table[data-tam="pastperf"] { background:#f5f0ff; }
table[data-tam="perfsub"] { background:#f5f5e0; }
</style>
</head>
<body>
<h1>ジョージア語動詞活用ジェネレーター</h1>
<label for="dictForm">辞書形: </label>
<input id="dictForm" type="text">
<button id="convButton">活用する</button>
<label for="verbType">型:</label>
<select id="verbType">
  <option value="I">Ⅰ型</option>
  <option value="II">Ⅱ型</option>
  <option value="III">Ⅲ型</option>
  <option value="IV">Ⅳ型</option>
</select>
<label><input type="checkbox" id="noHyphen">ハイフンを表示しない</label>
<div style="margin-top:0.5em">
  <label for="tamFilter">TAM:</label>
  <select id="tamFilter">
    <option value="">すべて</option>
    <option value="present">現在</option>
    <option value="imperfect">未完了過去</option>
    <option value="subj">接続法現在</option>
    <option value="future">未来</option>
    <option value="conditional">条件法</option>
    <option value="fsub">接続法未来</option>
    <option value="aorist">アオリスト</option>
    <option value="optative">希求法</option>
    <option value="presperf">現在完了</option>
    <option value="pastperf">過去完了</option>
    <option value="perfsub">接続法完了</option>
  </select>
  <label for="personFilter">人称:</label>
  <select id="personFilter">
    <option value="">--</option>
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
  </select>
  <label for="numberFilter">数:</label>
  <select id="numberFilter">
    <option value="">--</option>
    <option value="sg">単</option>
    <option value="pl">複</option>
  </select>
</div>
<div id="output"></div>
<script>
// 定義: 前母音・現在/未来マーカー・人称接尾辞
const PRE_VOWELS = ['ა', 'ე', 'ი', 'უ'];
const FUTURE_MARKERS = ['ამ', 'ავ', 'ებ', 'ობ', 'ოპ', 'ი', 'მ', 'ვ'];
const PERSON_SUFFIXES = ['ს', 'ა'];

function highlightType(suffix) {
  document.querySelectorAll('#verbType option').forEach(o => o.classList.remove('highlight'));
  if (suffix === 'ს') {
    document.querySelector('#verbType option[value="I"]').classList.add('highlight');
    document.querySelector('#verbType option[value="III"]').classList.add('highlight');
  } else if (suffix === 'ა') {
    document.querySelector('#verbType option[value="II"]').classList.add('highlight');
    document.querySelector('#verbType option[value="IV"]').classList.add('highlight');
  }
}

function applyFilter() {
  const t = document.getElementById('tamFilter').value;
  const p = document.getElementById('personFilter').value;
  const n = document.getElementById('numberFilter').value;
  document.querySelectorAll('#output table.tam').forEach(tab => {
    tab.style.display = !t || tab.dataset.tam === t ? '' : 'none';
  });
  document.querySelectorAll('#output tr.person-row').forEach(row => {
    const okP = !p || row.dataset.person === p;
    const okN = !n || row.dataset.number === n;
    row.style.display = okP && okN ? '' : 'none';
  });
}

function parseDictionaryForm(str) {
  const trimmed = str.trim();
  let preverb = '';
  let rest = trimmed;
  const eqIdx = trimmed.indexOf('=');
  if (eqIdx !== -1) {
    preverb = trimmed.slice(0, eqIdx);
    rest = trimmed.slice(eqIdx + 1);
  }
  const parts = rest.split('-').filter(p => p.length > 0);

  if (parts.length < 2) return null; // at least stem and suffix

  const suffix = parts.pop();
  if (!PERSON_SUFFIXES.includes(suffix)) return null;

  let preVowel = '';
  if (parts.length && parts[0].length === 1 && PRE_VOWELS.includes(parts[0])) {
    preVowel = parts.shift();
  }

  let stem = '', marker = '';
  if (parts.length === 2) {
    [stem, marker] = parts;
    if (!FUTURE_MARKERS.includes(marker)) return null;
  } else if (parts.length === 1) {
    [stem] = parts; // markerless
  } else {
    return null;
  }

  return { preverb, preVowel, stem, marker, suffix };
}

function buildForm(preVowel, stem, marker, suffix, infix, cond) {
  const tokens = [];
  if (infix) tokens.push(infix);
  if (preVowel) tokens.push(preVowel);
  tokens.push(stem);
  if (marker) tokens.push(marker);
  if (cond) tokens.push(cond);
  if (suffix) tokens.push(suffix);
  return tokens.join('-');
}

function buildFormFuture(preverb, preVowel, stem, marker, suffix, infix, cond) {
  const tokens = [];
  if (preverb) tokens.push(preverb);
  if (infix) tokens.push(infix);
  if (preVowel) tokens.push(preVowel);
  tokens.push(stem);
  if (marker) tokens.push(marker);
  if (cond) tokens.push(cond);
  if (suffix) tokens.push(suffix);
  return tokens.join('-');
}

function conjugatePresent(c) {
  const p = c.preVowel, s = c.stem, m = c.marker, base = c.suffix;
  return {
    '1sg': buildForm(p, s, m, '', 'ვ', ''),
    '2sg': buildForm(p, s, m, '', '', ''),
    '3sg': buildForm(p, s, m, base, '', ''),
    '1pl': buildForm(p, s, m, 'თ', 'ვ', ''),
    '2pl': buildForm(p, s, m, 'თ', '', ''),
    '3pl': buildForm(p, s, m, 'ენ', '', '')
  };
}

function conjugateImperfect(c) {
  const p = c.preVowel, s = c.stem, m = c.marker;
  const d = 'დ';
  return {
    '1sg': buildForm(p, s, m, 'ი', 'ვ', d),
    '2sg': buildForm(p, s, m, 'ი', '', d),
    '3sg': buildForm(p, s, m, 'ა', '', d),
    '1pl': buildForm(p, s, m, 'ით', 'ვ', d),
    '2pl': buildForm(p, s, m, 'ით', '', d),
    '3pl': buildForm(p, s, m, 'ნენ', '', d)
  };
}

function conjugateSubjunctive(c) {
  const p = c.preVowel, s = c.stem, m = c.marker;
  const d = 'დ';
  return {
    '1sg': buildForm(p, s, m, 'ე', 'ვ', d),
    '2sg': buildForm(p, s, m, 'ე', '', d),
    '3sg': buildForm(p, s, m, 'ეს', '', d),
    '1pl': buildForm(p, s, m, 'ეთ', 'ვ', d),
    '2pl': buildForm(p, s, m, 'ეთ', '', d),
    '3pl': buildForm(p, s, m, 'ნენ', '', d)
  };
}

function conjugatePresentII(c) {
  const p = c.preVowel, s = c.stem, m = c.marker;
  return {
    '1sg': buildForm(p, s, m, 'ი', 'ვ', ''),
    '2sg': buildForm(p, s, m, 'ი', '', ''),
    '3sg': buildForm(p, s, m, 'ა', '', ''),
    '1pl': buildForm(p, s, m, 'ით', 'ვ', ''),
    '2pl': buildForm(p, s, m, 'ით', '', ''),
    '3pl': buildForm(p, s, m, 'იან', '', '')
  };
}

function conjugateImperfectII(c) {
  const p = c.preVowel, s = c.stem, m = c.marker;
  const d = 'ოდ';
  return {
    '1sg': buildForm(p, s, m, 'ი', 'ვ', d),
    '2sg': buildForm(p, s, m, 'ი', '', d),
    '3sg': buildForm(p, s, m, 'ა', '', d),
    '1pl': buildForm(p, s, m, 'ით', 'ვ', d),
    '2pl': buildForm(p, s, m, 'ით', '', d),
    '3pl': buildForm(p, s, m, 'ნენ', '', d)
  };
}

function conjugateSubjunctiveII(c) {
  const p = c.preVowel, s = c.stem, m = c.marker;
  const d = 'ოდ';
  return {
    '1sg': buildForm(p, s, m, 'ე', 'ვ', d),
    '2sg': buildForm(p, s, m, 'ე', '', d),
    '3sg': buildForm(p, s, m, 'ეს', '', d),
    '1pl': buildForm(p, s, m, 'ეთ', 'ვ', d),
    '2pl': buildForm(p, s, m, 'ეთ', '', d),
    '3pl': buildForm(p, s, m, 'ნენ', '', d)
  };
}

function conjugateFutureII(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb;
  return {
    '1sg': buildFormFuture(pre, pv, s, m, 'ი', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, m, 'ი', '', ''),
    '3sg': buildFormFuture(pre, pv, s, m, 'ა', '', ''),
    '1pl': buildFormFuture(pre, pv, s, m, 'ით', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, m, 'ით', '', ''),
    '3pl': buildFormFuture(pre, pv, s, m, 'იან', '', '')
  };
}

function conjugateConditionalII(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb;
  const d = 'ოდ';
  return {
    '1sg': buildFormFuture(pre, pv, s, m, 'ი', 'ვ', d),
    '2sg': buildFormFuture(pre, pv, s, m, 'ი', '', d),
    '3sg': buildFormFuture(pre, pv, s, m, 'ა', '', d),
    '1pl': buildFormFuture(pre, pv, s, m, 'ით', 'ვ', d),
    '2pl': buildFormFuture(pre, pv, s, m, 'ით', '', d),
    '3pl': buildFormFuture(pre, pv, s, m, 'ნენ', '', d)
  };
}

function conjugateFutureSubjunctiveII(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb;
  const d = 'ოდ';
  return {
    '1sg': buildFormFuture(pre, pv, s, m, 'ე', 'ვ', d),
    '2sg': buildFormFuture(pre, pv, s, m, 'ე', '', d),
    '3sg': buildFormFuture(pre, pv, s, m, 'ეს', '', d),
    '1pl': buildFormFuture(pre, pv, s, m, 'ეთ', 'ვ', d),
    '2pl': buildFormFuture(pre, pv, s, m, 'ეთ', '', d),
    '3pl': buildFormFuture(pre, pv, s, m, 'ნენ', '', d)
  };
}

function conjugateFuture(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb, base = c.suffix;
  return {
    '1sg': buildFormFuture(pre, pv, s, m, '', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, m, '', '', ''),
    '3sg': buildFormFuture(pre, pv, s, m, base, '', ''),
    '1pl': buildFormFuture(pre, pv, s, m, 'თ', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, m, 'თ', '', ''),
    '3pl': buildFormFuture(pre, pv, s, m, 'ენ', '', '')
  };
}

function conjugateConditional(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb;
  const d = 'დ';
  return {
    '1sg': buildFormFuture(pre, pv, s, m, 'ი', 'ვ', d),
    '2sg': buildFormFuture(pre, pv, s, m, 'ი', '', d),
    '3sg': buildFormFuture(pre, pv, s, m, 'ა', '', d),
    '1pl': buildFormFuture(pre, pv, s, m, 'ით', 'ვ', d),
    '2pl': buildFormFuture(pre, pv, s, m, 'ით', '', d),
    '3pl': buildFormFuture(pre, pv, s, m, 'ნენ', '', d)
  };
}

function conjugateFutureSubjunctive(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, m = c.marker, pre = c.preverb;
  const d = 'დ';
  return {
    '1sg': buildFormFuture(pre, pv, s, m, 'ე', 'ვ', d),
    '2sg': buildFormFuture(pre, pv, s, m, 'ე', '', d),
    '3sg': buildFormFuture(pre, pv, s, m, 'ეს', '', d),
    '1pl': buildFormFuture(pre, pv, s, m, 'ეთ', 'ვ', d),
    '2pl': buildFormFuture(pre, pv, s, m, 'ეთ', '', d),
    '3pl': buildFormFuture(pre, pv, s, m, 'ნენ', '', d)
  };
}

function conjugateAorist(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, pre = c.preverb;
  return {
    '1sg': buildFormFuture(pre, pv, s, '', 'ე', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, '', 'ე', '', ''),
    '3sg': buildFormFuture(pre, pv, s, '', 'ა', '', ''),
    '1pl': buildFormFuture(pre, pv, s, '', 'ეთ', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, '', 'ეთ', '', ''),
    '3pl': buildFormFuture(pre, pv, s, '', 'ეს', '', '')
  };
}

function conjugateAoristII(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, pre = c.preverb;
  return {
    '1sg': buildFormFuture(pre, pv, s, '', 'ე', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, '', 'ე', '', ''),
    '3sg': buildFormFuture(pre, pv, s, '', 'ა', '', ''),
    '1pl': buildFormFuture(pre, pv, s, '', 'ეთ', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, '', 'ეთ', '', ''),
    '3pl': buildFormFuture(pre, pv, s, '', 'ნენ', '', '')
  };
}

function conjugateOptative(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, pre = c.preverb;
  return {
    '1sg': buildFormFuture(pre, pv, s, '', 'ო', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, '', 'ო', '', ''),
    '3sg': buildFormFuture(pre, pv, s, '', 'ოს', '', ''),
    '1pl': buildFormFuture(pre, pv, s, '', 'ოთ', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, '', 'ოთ', '', ''),
    '3pl': buildFormFuture(pre, pv, s, '', 'ონ', '', '')
  };
}

function conjugateOptativeII(c) {
  if (!c.preverb) return null;
  const pv = c.preVowel, s = c.stem, pre = c.preverb;
  return {
    '1sg': buildFormFuture(pre, pv, s, '', 'ო', 'ვ', ''),
    '2sg': buildFormFuture(pre, pv, s, '', 'ო', '', ''),
    '3sg': buildFormFuture(pre, pv, s, '', 'ოს', '', ''),
    '1pl': buildFormFuture(pre, pv, s, '', 'ოთ', 'ვ', ''),
    '2pl': buildFormFuture(pre, pv, s, '', 'ოთ', '', ''),
    '3pl': buildFormFuture(pre, pv, s, '', 'ონ', '', '')
  };
}

function conjugatePresentPerfect(c) {
  const pre = c.preverb, s = c.stem, m = c.marker;
  return {
    '1sg': buildFormFuture(pre, 'ი', s, m, 'ია', 'მ', ''),
    '2sg': buildFormFuture(pre, 'ი', s, m, 'ია', 'გ', ''),
    '3sg': buildFormFuture(pre, 'უ', s, m, 'ია', '', ''),
    '1pl': buildFormFuture(pre, 'ი', s, m, 'ია', 'გვ', ''),
    '2pl': buildFormFuture(pre, 'ი', s, m, 'იათ', 'გ', ''),
    '3pl': buildFormFuture(pre, 'უ', s, m, 'იათ', '', '')
  };
}

function conjugatePastPerfect(c) {
  const pre = c.preverb, s = c.stem, m = c.marker;
  return {
    '1sg': buildFormFuture(pre, 'ე', s, m, 'ინა', 'მ', ''),
    '2sg': buildFormFuture(pre, 'ე', s, m, 'ინა', 'გ', ''),
    '3sg': buildFormFuture(pre, 'ე', s, m, 'ინა', '', ''),
    '1pl': buildFormFuture(pre, 'ე', s, m, 'ინა', 'გვ', ''),
    '2pl': buildFormFuture(pre, 'ე', s, m, 'ინათ', 'გ', ''),
    '3pl': buildFormFuture(pre, 'ე', s, m, 'ინათ', '', '')
  };
}

function conjugatePerfectSubjunctive(c) {
  const pre = c.preverb, s = c.stem, m = c.marker;
  return {
    '1sg': buildFormFuture(pre, 'ე', s, m, 'ინოს', 'მ', ''),
    '2sg': buildFormFuture(pre, 'ე', s, m, 'ინოს', 'გ', ''),
    '3sg': buildFormFuture(pre, 'ე', s, m, 'ინოს', '', ''),
    '1pl': buildFormFuture(pre, 'ე', s, m, 'ინოს', 'გვ', ''),
    '2pl': buildFormFuture(pre, 'ე', s, m, 'ინოთ', 'გ', ''),
    '3pl': buildFormFuture(pre, 'ე', s, m, 'ინოთ', '', '')
  };
}

function formatForm(str) {
  if (document.getElementById('noHyphen').checked) {
    return str.replace(/-/g, '');
  }
  return str;
}

function renderTable(title, forms, key) {
  const rows = [
    ['1sg', '1単', 'sg', '1'],
    ['2sg', '2単', 'sg', '2'],
    ['3sg', '3単', 'sg', '3'],
    ['1pl', '1複', 'pl', '1'],
    ['2pl', '2複', 'pl', '2'],
    ['3pl', '3複', 'pl', '3']
  ];
  let html = '<details open><summary>' + title + '</summary>' +
    '<table class="tam" data-tam="' + key + '">' +
    '<tr class="header"><th>人称</th><th>活用形</th></tr>';
  rows.forEach(r => {
    html += '<tr class="person-row" data-number="' + r[2] + '" data-person="' + r[3] + '"><th>' + r[1] + '</th><td>' + formatForm(forms[r[0]]) + '</td></tr>';
  });
  html += '</table></details>';
  return html;
}

function generate() {
  const input = document.getElementById('dictForm').value;
  const comp = parseDictionaryForm(input);
  if (!comp) {
    document.getElementById('output').textContent = '解析できませんでした。';
    return;
  }
  highlightType(comp.suffix);
  const type = document.getElementById('verbType').value;
  const pres = type === 'II' ? conjugatePresentII(comp) : conjugatePresent(comp);
  const impf = type === 'II' ? conjugateImperfectII(comp) : conjugateImperfect(comp);
  const subj = type === 'II' ? conjugateSubjunctiveII(comp) : conjugateSubjunctive(comp);
  const pperf = conjugatePresentPerfect(comp);
  const iperf = conjugatePastPerfect(comp);
  const sperf = conjugatePerfectSubjunctive(comp);
  let html = '';
  html += renderTable('現在', pres, 'present');
  html += renderTable('未完了過去', impf, 'imperfect');
  html += renderTable('接続法現在', subj, 'subj');

  if (comp.preverb) {
    const fut = type === 'II' ? conjugateFutureII(comp) : conjugateFuture(comp);
    const cond = type === 'II' ? conjugateConditionalII(comp) : conjugateConditional(comp);
    const fsub = type === 'II' ? conjugateFutureSubjunctiveII(comp) : conjugateFutureSubjunctive(comp);
    html += renderTable('未来', fut, 'future');
    html += renderTable('条件法', cond, 'conditional');
    html += renderTable('接続法未来', fsub, 'fsub');
  } else {
    html += '<p>この動詞は未来亜系統には活用できません</p>';
  }

  if (comp.preverb) {
    const aor = type === 'II' ? conjugateAoristII(comp) : conjugateAorist(comp);
    const opt = type === 'II' ? conjugateOptativeII(comp) : conjugateOptative(comp);
    html += renderTable('アオリスト', aor, 'aorist');
    html += renderTable('希求法', opt, 'optative');
  } else {
    html += '<p>この動詞はアオリスト亜系統には活用できません</p>';
  }

  html += renderTable('現在完了', pperf, 'presperf');
  html += renderTable('過去完了', iperf, 'pastperf');
  html += renderTable('接続法完了', sperf, 'perfsub');
  document.getElementById('output').innerHTML = html;
  applyFilter();
  document.querySelectorAll('#output td').forEach(td => {
    td.addEventListener('click', () => {
      navigator.clipboard.writeText(td.textContent).then(() => {
        td.classList.add('copied');
        setTimeout(() => td.classList.remove('copied'), 600);
      });
    });
  });
}

document.getElementById('convButton').addEventListener('click', generate);
document.getElementById('tamFilter').addEventListener('change', applyFilter);
document.getElementById('personFilter').addEventListener('change', applyFilter);
document.getElementById('numberFilter').addEventListener('change', applyFilter);
document.getElementById('noHyphen').addEventListener('change', generate);
</script>
</body>
</html>
